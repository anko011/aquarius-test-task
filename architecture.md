# Архитектура приложения

В качестве архитектурного подхода был выбран SPA (Single Page Application), так как этот подход идеально подходит для
внутреннего веб-приложения с динамическим и интерактивным интерфейсом. В отличие от SSR (Server-Side Rendering), SPA не
требует сложной серверной настройки, так как весь контент генерируется на клиенте, что упрощает конфигурацию и
развертывание.

## Основными преимуществами SSR перед SPA являются:

SSR улучшает SEO за счет готовой разметки и снижает нагрузку на клиент, так как вычисления выполняются на сервере.
Однако для высокоинтерактивных проектов (например, с графиками и таблицами) SPA подходит лучше, так как обеспечивает
большую динамичность и отзывчивость.

Для тестового задания было выбрано SPA, что позволило сократить время разработки и упростить архитектуру.

Проект структурирован с использованием Feature Slice Design (FSD), что повышает гибкость и масштабируемость. FSD
улучшает модульность, снижает связанность компонентов, облегчает тестирование и поддержку, а также упрощает добавление
новых функций.

## Основные принципы FSD

Методология FSD разделяет приложение на слои с однонаправленной зависимостью, что обеспечивает модульность и
устойчивость к изменениям. Слои организованы следующим образом:

+ app: Инициализация проекта, маршруты, провайдеры, глобальная конфигурация.
+ pages: Страницы приложения, каждая из которых состоит из виджетов и функциональных блоков.
+ widgets: Повторно используемые интерфейсные блоки с логикой.
+ features: Реализация функционала, ориентированного на взаимодействие с пользователем.
+ entities: Переиспользуемые компоненты, связанные с бизнес-логикой.
+ shared: Утилиты, компоненты, библиотеки, типы, не связанные с бизнес-логикой.

Каждый слой (кроме app и shared) делится на модули:

+ api: Взаимодействие с внешними API.
+ model: Обработка данных и бизнес-правила.
+ ui: Компоненты интерфейса.
+ config: Статическая конфигурация модуля.

## Подход Page-First

Подход Page-First основан на идее декомпозиции компонентов по мере необходимости. Компоненты располагаются как можно
ближе к месту их использования, что позволяет минимизировать количество «слоёв» и обеспечивает более эффективный и
органичный дизайн.
FSD основывается на концепции «высокой связности и низкой связанности» (High Cohesion, Low Coupling), что позволяет
создавать более структурированные и управляемые приложения.

## Подход рендер- и контейнер-компонентов

В рамках FSD используется подход, основанный на разделении компонентов на две категории: контейнерные и
рендер-компоненты:

+ Рендер-компоненты отвечают исключительно за визуализацию данных и управление состоянием, необходимым для отображения.
+ Контейнерные компоненты обеспечивают композицию рендер-компонентов и включают логику обработки данных, а также
  взаимодействие с API.

# Выбор технологий

Для реализации тестового задания были выбраны инструменты и библиотеки, обеспечивающие баланс между производительностью,
функциональностью и простотой разработки. Уделено внимание удобству интерфейса, производительности визуализации данных,
лицензиям и качеству продукта.

## React

Выбор React обоснован его популярностью, компонентной архитектурой, богатой экосистемой и высокой производительностью.

*Альтернативы:*

+ Angular — для крупных приложений с сложной логикой.
+ Vue.js — для легковесных и быстрых прототипов.
+ Svelte — улучшенная производительность через компиляцию.
+ Astro — для статичных сайтов.

## Recharts

Recharts выбран для визуализации данных благодаря простоте использования, поддержке различных типов графиков и хорошей
интеграции с React.

*Альтернативы:*

+ Chart.js — меньше функционала в интеграции с React.
+ Highcharts — мощный, но платный.
+ D3.js — более гибкий, но сложный в настройке.

## React-virtualized

Библиотека для виртуализации таблиц, поддерживающая ленивую загрузку и оптимизированная для работы с большими объемами
данных.

*Альтернативы:*

+ react-window — легковесный, но с ограниченными возможностями.
+ TanStack Table — более функциональный, но с большим размером бандла.

## CSS Modules

CSS Modules гарантируют уникальные классы, избегая конфликтов и упрощая управление стилями.

Альтернативы:

+ SCSS, Less — требующие дополнительной настройки.
+ CSS-in-JS — упрощает стили, но может снизить производительность.
+ Tailwind — ускоряет разработку, но не всегда удобен для сложных стилей.

## React Error Boundary

React Error Boundary перехватывает ошибки в компонентами и поддерживает fallback UI.

*Альтернатива:*
Собственная реализация классового компонента, если функционал недостаточен.

## Superstruct

Superstruct используется для валидации данных благодаря своей простоте, совместимости с TypeScript и высокой
производительности.

*Альтернатива:*

+ Zod — более мощный, но с меньшей производительностью.

## Vite

Vite выбран для быстрого старта и сборки проекта с использованием ES-модулей и минимальной конфигурации.

*Альтернативы:*

+ Webpack — мощный, но медленный на разработке.
+ Parcel — быстрее, но с меньшей экосистемой.
+ esbuild, Turbopack — быстрые, но с ограниченной поддержкой.

###Typedoc

Typedoc используется для генерации документации из комментариев в коде, синхронизированной с TypeScript.

*Альтернатива:*

+ Storybook — для интерактивной документации с рендером компонентов, но требует отдельной настройки.

## Prettier и ESLint

Prettier и ESLint обеспечивают консистентность и качество кода.

## Vitest и React Testing Library

Vitest для быстрого тестирования, React Testing Library — для тестирования интерфейса с точки зрения пользователя.

*Альтернатива:*

+ Jest — медленнее, чем Vitest.
+ Enzyme — устаревший инструмент.

## Nginx

Nginx выбран для раздачи статики, обеспечивая высокую производительность и легкость в конфигурации.

*Альтернатива:*

+ Apache HTTP Server — для SSR с PHP, но более ресурсоемкий.
+ Caddy — простой, но менее масштабируемый.